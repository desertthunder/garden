{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About This Site","text":"<p>Hi! My name is Owais and this is my digital garden. It's a collection of notes I've taken on topics that interest me. This includes a lot of engineering and programming notes that I've taken throughout my career and while working on personal projects. My hope is that someone learns something new or finds some wisdom that resonates with them.</p> <p>Digital gardens have been fascinating for me for a long time. I miss the days of stumbling upon information on an odd personal site on the internet and want to be a part of bringing that back. I've tried keeping gardens in various iterations with tools like notion and even google drive, but nothing has been quite as consistent as a combination of some plaintext editor (VSCode &amp; now Neovim) or \"Knowledge IDE\" like Obsidian.</p> <p></p>"},{"location":"#my-tools","title":"My Tools","text":"<ul> <li>Fedora &amp; MacOS</li> <li>Alacritty</li> <li>Zsh</li> <li>Neovim</li> </ul> <ul> <li>Obsidian</li> <li>VSCode</li> </ul>"},{"location":"#attributions","title":"Attributions","text":"<p>Lightning Site Icon by zky.icon from Flaticon</p>"},{"location":"data-structures/","title":"Data Structures","text":""},{"location":"data-structures/arrays/","title":"Arrays &amp; Data Structure Basics","text":"<ul> <li>MIT 6.006 Lecture: https://www.youtube.com/watch?v=CHhwJjR0mZA</li> <li>Take a look at lecture notes on the website for addl. information.</li> </ul>"},{"location":"data-structures/arrays/#basics","title":"Basics","text":"<ul> <li>Interface (API, or Abstract Data Type) tells you what you want to do (specification)</li> <li>What operations do, are supported, and their meaning</li> <li>In contrast a data structure tells you how (to store)</li> <li>We're given algorithms to tell us how to support those operations</li> <li>In algorithms we care a lot about scalability for very large N.</li> </ul>"},{"location":"data-structures/arrays/#sequences","title":"Sequences","text":"<ul> <li>Static sequence interface: number of items does not change (Build, Length, Get, Set, Iteration)</li> </ul>"},{"location":"data-structures/arrays/#arrays","title":"Arrays","text":"<ul> <li>Memory Allocation Model - you can allocate an array of size N, in O(N) (it takes linear time)</li> <li>The amount of space you use to allocate the array is the amount of time it took.</li> <li>Access is constant time - we need to assume that W is at least log(N) to address all N items in my input.</li> <li>W is the machine word size, which is 64 bits on most modern machines.</li> <li>We want to be able to insert or delete from the middle of the sequence. i.e. Insert At or Delete At.</li> <li>Inserting or Deleting at the beginning requires you to re-index everything</li> </ul>"},{"location":"data-structures/arrays/#linked-lists","title":"Linked Lists","text":"<ul> <li>We store our items in Nodes, in order</li> <li>Each item has a Node, and a next field (pointer)</li> <li>We need to track the Head Node</li> </ul>"},{"location":"data-structures/arrays/#dynamic-arrays","title":"Dynamic Arrays","text":"<ul> <li>aka Python's lists</li> <li>Relax the constraint that the size of the array we use equals N</li> <li>\"Roughly\" means throw away constant factors when making approximations</li> <li>Add to end unless length equals size, we're out of space.</li> <li>In a static array, we have to allocate a new array of size N + 1 when adding one element.</li> <li>In contrast, a dynamic array we allocate a new array of the original size plus some constant. It's approximately the same as a static array because we don't use constants in approximations.</li> <li>Constant amoritization analysis averages the running times of operations in a sequence over that sequence</li> </ul>"},{"location":"data-structures/arrays/#recap","title":"Recap","text":"<ul> <li>What's an interface? How does a data structure relate?</li> <li>What is the interface for a static sequence?</li> <li>What is the Memory Allocation Model?</li> <li>Dynamic v. Static array allocation</li> <li>What is amoritization?</li> </ul>"},{"location":"data-structures/stacks/","title":"Stacks","text":"<ul> <li>Sources</li> <li>William Fiset (YouTube)</li> </ul>"},{"location":"data-structures/stacks/#what-is-a-stack","title":"What is a stack?","text":"<ul> <li>A one-ended linear data structure that models a real stack.</li> <li>Two operations, push (to top), pop (off the top)</li> <li>We can only act on top of the stack</li> <li>Last In, First Out (LIFO)</li> </ul>"},{"location":"data-structures/stacks/#example-problems","title":"Example Problems","text":"<ul> <li>Brackets (validate that brackets are closed).</li> <li>ex. <code>[[{}]()]</code></li> <li>Steps</li> <li>Push <code>[</code>: <code>[</code></li> <li>Push <code>[</code>: <code>[[</code></li> <li>Push <code>{</code>: <code>[[{</code></li> <li>Pop <code>{</code> (we hit <code>}</code>): <code>[[</code></li> <li>Pop <code>[</code>: <code>[</code></li> <li>Push <code>(</code>: <code>[(</code></li> <li>Pop <code>(</code>: <code>[</code></li> <li>Pop <code>[</code>: <code>...</code></li> <li>Since the stack is now empty, the bracket sequence is valid</li> <li>Tower of Hanoi Game</li> <li>Three pegs are stacks.</li> <li>No disk can be placed on smaller disk</li> <li>Move disks from one end to the other</li> </ul>"},{"location":"data-structures/stacks/#stack-implementation","title":"Stack Implementation","text":"<ul> <li>Usually implemented with linked lists or arrays.</li> </ul>"},{"location":"data-structures/stacks/#singly-linked-list","title":"Singly Linked List","text":"<ul> <li>Start with null node.</li> <li>Create new heads with pointer to newest node (push)</li> <li>Move head pointer to next node, and dereference old head (pop)</li> </ul>"},{"location":"data-structures/stacks/#source-code","title":"Source Code","text":"<ul> <li><code>java.util</code> has a LinkedList</li> <li>implements the iterable interface (has a generic)</li> </ul>"},{"location":"data-structures/stacks/#questions","title":"Questions","text":"<ul> <li>What is a concurrent modification error?</li> </ul>"},{"location":"data-structures/trees/","title":"Trees","text":"<p>\"All roads lead to trees.\" Examples: DOM, Filesystem (hard drive)</p>"},{"location":"data-structures/trees/#terminology","title":"Terminology","text":"<ul> <li>root: topmost parent node</li> <li>height: longest path from root the youngest (bottommost) child node</li> <li>binary tree: a tree with at most 2 children</li> <li>general tree: a tree with more than 0 children</li> <li>balanced tree: a tree is perfectly balanced when any node's left and right children have the same height</li> <li>branching factor: amount of children a tree has</li> </ul>"},{"location":"data-structures/trees/#traversal","title":"Traversal","text":"<ul> <li>Review recursion!</li> <li>Visit a node and then recurse is pre-order traversal.</li> <li>In languages where you have to clean up memory, you do a post-order traversal.</li> <li>preorder root's at beginning, in order root's at the middle, post-order root's at the end.</li> <li>All traversals are <code>O(n)</code> because for all traversals you visit every node.</li> <li>We're implicitly using a stack when we do depth first search. Makes sense because we're leveraging the call stack.</li> </ul>"},{"location":"data-structures/trees/#references","title":"References","text":"<ul> <li>ThePrimeagen</li> </ul>"},{"location":"programming/","title":"Programming","text":"<p>This will contain notes related to programming languages I've \"learned\" or am learning. Can you ever really know a programming language top to bottom unless you wrote it?</p>"},{"location":"programming/#languages","title":"Languages","text":"<ul> <li>TypeScript</li> <li>Python</li> <li>Java</li> <li>Ruby</li> <li>Go</li> </ul>"},{"location":"programming/#languages-to-learn","title":"Languages to Learn","text":"<p>As of May 2024, these are languages that are on my radar to learn:</p> <ul> <li>C++</li> <li>Elixir</li> <li>Rust</li> <li>Elm</li> </ul>"}]}